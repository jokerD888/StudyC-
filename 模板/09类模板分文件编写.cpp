#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
using namespace std;

//学习目标：
//掌握类模板成员函数分文件编写产生的问题以及解决方式,
//问题：
// 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到
//原因：
//从语法角度而言，是没有强制要求说模板代码的声明和实现不可以分开。
// 那么当分离的声明和实现写好后，单独编译.cpp是可以通过的，但是生成的.o文件却非常小，只有一个原因：确实没有任何实现代码！――――不知道用什么类型参数套用模板。
//因为模板类需要在使用到的地方利用声明模板的typename或者class参数的时候，才会即时生成代码。那么当我把模板声明和实现分开的时候，
//这个即时过程因为编译器只能通过代码include“看到”头文件而找不到模板实现代码，所以会产生链接问题。这也是为什么几乎都会建议模板类和声明和实现都写在头文件。

//如果刚接触c / c++编写的朋友可能还不是很明白。编译器面对巨量代码的时候，也是以一个一个的.cpp / .c文件作为基本单元，根据代码的include包含找到声明，
//翻译代码产生.o文件。注意他们每个cpp / c文件都是相互独立完成自己工作的，对于缺少的部分，如果妥善声明，会留待链接过程的时候产生引用关系。 
//那么刚才说的模板类实现代码，编译它的时候因为不知道套用什么参数，实际上没有任何有用的内容存在于.o文件当中。
//而在使用模板类的地方指定了类型参数，编译器这才开始根据模板代码产生有用的.o编码，可是这些内容放在了使用模板的代码产生的.o文件当中。
//如果编译  使用模板代码的时候，通过include包含“看不到”模板的实现代码，这些所有的缺失，到链接阶段就无法完成。
// 
//解决：
// 解决方式1：直接包含.cpp源文件
//解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制
//主流是方式2

//#include"person.cpp"
#include"person.hpp"
void test01()
{
	Person<string, int> p("Tom", 20);	//如果类模板像其之前那样，声明写在头文件，实现写在源文件的话，在此就会报错，无法解析的外部文件，显然是链接过程中出现了错误
	p.ShowPerson();						//这就是类模板像往常一样分文件编写出现的问题，解决方法有两个，直接包含源文件，或者将类模板声明和实现写在同一文件
}

int main(void)
{

	test01();
	return 0;;
}
